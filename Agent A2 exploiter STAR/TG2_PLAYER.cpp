/*********************************                       
TG2 Player
*************************** top_eye_flop.cpp ***************************       
PLAYER TG2 baked by TG1 

step 1: retake hard players
step 2: if O not win invoke TG2 -- now clever two rail moves should apper  - !if(stop) 

Winner takes all,  neurotransmitter discharge

It learns moves that creates duble rail for X
Prof  Oscar  Chang  
October 13, 2022 
Student name:     Chesus count_peak_values(
/*********************************************************************/               
//----------------------------------------------
// GLOBALS
// GLOBALS
#define f_dimension     9   //   tamaño del agente, cuantos comportamientos participan 
long int cycles=0;    
int b_flag;
int stop;
char dummy[1];
//--moveto(400,20);
float f_k_heat;
int f_winner;
int f_cycle_count;
float f_k_increment;
float f_threshold=0.7;                      //  Umbral de i_agent
int f_winner_count[f_dimension];
int f_fractal_count[f_dimension];

int flip[f_dimension];  
float femp; 

char board[9];
char board_temp[9];
int  moves_counter;
//int  turn_to_play_O;

int end_game_flag;

int master_brake;

float sparse_input[27];    
int win_O_bell;
int win_X_bell;

int games_played;
int games_won_O;
int games_won_X;

float auto_seal_weight=-0.05;  // -0.05;   cantidad CRITICA que autosella a los ganadores del flop para que no repitan

int image_in_use;
int play_order[9];

int play_ok_flag_O;

int learn_input_pointer;

int image_pointer;
int p_flag;

int player_selector;


int bars_scale =50; int x_print, y_print=10;
int net_winner=0;
int winner_y=0;

int winner_net;
float story[9][27];  // 9 jugadas (plays)  27 entradas,  primer indice es jugada,  segundo es valor de neurona segun tablero   
int story_pointer;

int q_flag;
int backpro_count;
float winner_record_O;
float winner_record_X;
char key, color;

int game_open_case;
int zone_pointer;

int max_moves=8;
int target_timer;
float peak_value;
int net_advice;

int target_pointer;
int TG1_flag;
int peak_count;

//----------------------------------------)))
//    end globals
//----------------------------------------)))
#include <stdlib.h>
#include <graphics.h>
#include <dos.h>
#include <conio.h>
#include <stdio.h>
#include <math.h>
#include <iostream>
#include <iomanip.h>
#include <windows.h>

#include "neural_lib_mmt.h"
#include "plot_net_items.h"
#include "print_console.h"
#include "handle_net_items.h"
#include "check_game_win.h"
#include "O_learns.h"
#include "cargar_pesos.h"
#include "pop_push_pesos.h"
#include "salvar_pesos.h"

/******************* variables globales *********************/
using namespace std;
//-------------------------------------
//    inicia el modo grafico             
//-------------------------------------    
void grafico(void)
{
    int    GraphDriver;  /* The Graphics device driver */
    int    GraphMode;    /* The Graphics mode value */
    int    ErrorCode;    /* Reports any graphics errors */
   
    initgraph(&GraphDriver, &GraphMode, "");

    ErrorCode = graphresult();            /* Read result of initialization*/
    if( ErrorCode != grOk )              /* Error occured during init    */
    {
       printf(" Graphics System Error: %s", grapherrormsg( ErrorCode ) );
       exit( 1 );
    }
}
//----&&---------------------------------------------
void clean_board(void)
{ 
  int i;
  for (i=0; i<9;i++)   board[i]='-';     

}
//-------------------------------------  
void erase_screen(void)
{
   setcolor(LIGHTGRAY);  
   setfillstyle(SOLID_FILL,LIGHTGRAY);     
   bar(150,100,350,300) ;         //  200   150   303   253
   floodfill(255,205,BLACK);    
}
//------------------------------------                                           
void init_game(void)            //                   $$$$$$$$$$$$$   INIT GAME
{
 win_O_bell=0; 
 win_X_bell=0;   
 clean_board();
 player_selector=0;        // O es mano
    
 //player_selector=random(2);     //     EVEN condition
    
 moves_counter=0;  
 fill_inputs();   
    
 print_graph_parameters();
}
//-----------------------------------------------------------
void end_game(void)                   //       ---------------->       END GAME
{
 games_played++;   
 init_game();    
}
//----------------------------------------------------------
void consult_net_1(void)                  
{
   fire_net_1();
   busca_neuron_ganador();  
   print_graph_parameters();     
   plot_game_graphics();   
   if(peak_value>0.45) TG1_flag=1; 
   else TG1_flag=0;    
}

//----------------------------------------------------------
void consult_net_2(void)                  
{
   fire_net_2();
   busca_neuron_ganador();  
   print_graph_parameters();     
   plot_game_graphics();   
   if(peak_value>0.45) {flash(net_winner);getch();}    
}
//---------------------------------------------------------
//----------------------------------------------------------
void explore_future(void)            
{
 int i, temp;
    
  for(int j=0;j<N_OUT;j++) Target[j]=0.0;   // se limpian los targets 
      
  for(i=0;i<9;i++)        //    explora todos los cuadros
  {
    if(board[i]=='-')     //  se buscan cuadros vacios
         {
           
          board[i]='O';   //  se coloca una O para explorar
          check_TG1_energy(); 
          if(peak_count>1)              
            { 
              temp=i;  
              Target[temp]=1.0;      //  ojo este target viene de TG1   1 * *     
              board[i]='-';          //  se regresa a la jugada anterior  
              cout << "HIGH ENERGY DOUBLE"<<endl;
             
              plot_targets();
              if(stop) flash(i); 
              fire_net_2();
              busca_neuron_ganador();  
              print_graph_parameters();     
              plot_game_graphics();  
              delay(1);                          
              if(stop) getch(); 
              Target[temp]=0.0; 
              plot_targets();  
            }
          board[i]='-';
        }  
  }  
}
//----------------------------------------------------------
void explore_double_rail(void)            
{
 int i, temp;
    
        check_TG1_energy(); 
          if(peak_count>1)              
            { 
              cout << "HIGH ENERGY DOUBLE"<<endl;
              fire_net_2();
              busca_neuron_ganador();  
              print_graph_parameters();     
              plot_game_graphics();  
              delay(1);                          
              if(stop) getch(); 
  
            }
}
//-----------------------------------------------------------
void train(void)  //                                                                TRAIN  !!                        &&&/&&/&&/////
{
   while(1)
    {               
     player_selector=player_selector^1;   // se alternan los jugadores      
             
     if(player_selector)  {
                           //if(moves_counter>0) explore_future();
                           consult_net_1();
                           if(!TG1_flag) consult_net_2();
                           O_plays(); 
                          }      
                    
     if(!player_selector) {
                            pop_pesos_net1(); 
                            //X_plays();
                            X_plays_clever();
                          }                                   
     moves_counter++;      
     
     if (moves_counter>max_moves)  end_game();  //    >5     O_learns();      
         
     check_game_winner(); 
     if(win_O_bell) end_game();
     if(win_X_bell) end_game();
         
     //if(player_selector) check_TG1();
         
     if(stop)break;
     if(kbhit()) break;    
    }
    
 
    
   
}    
//------------------------------------------------------
//===============================================================================================
void main(void)
{ 
 int i;  
 
  
    clean_board();    
    clrscr();                   // limpia la pantalla
    grafico();                  // prepara modo grafico   
    cleardevice();              // limpia la pantalla windows
    
    
    setcolor(LIGHTGRAY);
    bar(0,0,1400,900);       //    limpia pantalla
 
    //srand(10); 
    for(i=0;i<N_OUT;i++) Target[i]=0.1;
    plot_targets();     
    init_game(); 
    plot_game_graphics();   
    plot_board_map();  

    randomize();    
    //inicializar_pesos();
    //SalvarPesos_net2();
    
    //getch();
    
    CargarPesos_net1();
    CargarPesos_net2(); 
    
    //inicializar_pesos();
    games_played=1;
    stop=0;
    b_flag=0;
    q_flag=0;
    train();
    
    do {
       //play_flag=0; 
       key=getch();
       switch (key) {
           case '1':         {
               
               
                               train();
                             }
           break;                    
           case '2':          {
                                   
                            
					          }
	       break;
              
                 
           case ',':           { 
               
         
							   }
	       break;                              
           case '.':           { 
               
                         
							   }
	       break;                        
                                
           case 'b': case 'B':  {
                                   b_flag=b_flag^1;
                                    //icon_flag=1;
                                    //stop=0;
                                    train();
                                }
           break;  
                                
                         
            case ' ':             {                     //-------    HERE  ! !!!!!!!!!!!!!!!!         !!!!!!!!!!!!1
                                    
                                   stop=stop^1;
                                   train();
                                  }                                     
                                  
                                  
            break; 
            case 'R': case 'r':  {
                                   inicializar_pesos();
                                   push_pesos_net2();
                                   backpro_count=0; 
                                   train();
                                 }
            break;                     
                                
                                
            case 's': case 'S': {
                                //trim_pesos();   
                                pop_pesos_net2();
                                SalvarPesos_net2();
                                train(); 
                                }
	       break;                                                  
           case 'c': case 'C': {
                                CargarPesos();
                                train(); 
                               }
	       break;                
          
           case 'p': case 'P': {
                                stop=1;  
                                if(win_O_bell) end_game();
                                cout << "p depressed --"<<endl;    
                                train();                              
                               }
	       break;    
           case 'q': case 'Q': {
                                q_flag=1;
                                key='$';
                                //Sleep(100);   
                                train();                            
                               }
	       break;  
                 
                               
         }
   } while ((key!='x')&&(key!='X'));

   closegraph();
   clrscr();
}

//---------------------------------------
/*
BLACK        ³  0  ³ Yes ³ Yes
BLUE         ³  1  ³ Yes ³ Yes
GREEN        ³  2  ³ Yes ³ Yes
CYAN         ³  3  ³ Yes ³ Yes
RED          ³  4  ³ Yes ³ Yes
MAGENTA      ³  5  ³ Yes ³ Yes
BROWN        ³  6  ³ Yes ³ Yes
LIGHTGRAY    ³  7  ³ Yes ³ Yes
DARKGRAY     ³  8  ³ No  ³ Yes
LIGHTBLUE    ³  9  ³ No  ³ Yes
LIGHTGREEN   ³ 10  ³ No  ³ Yes
LIGHTCYAN    ³ 11  ³ No  ³ Yes
LIGHTRED     ³ 12  ³ No  ³ Yes
LIGHTMAGENTA ³ 13  ³ No  ³ Yes
YELLOW       ³ 14  ³ No  ³ Yes
WHITE        ³ 15  ³ No  ³ Yes

----------------------------------------------------------------
     if(x<0)    { x=0; if( heat<100) heat++;}     
     if(y<35)    { y=35; if( heat<100) heat++;}  
     if(x>640) { x=640; if( heat<100) heat++;}  //  x>1200 : full pantalla 
     if(y>470) { y=470; if( heat<100) heat++;}   // y>720 : full pantalla 
         
//--------------------------------------------------

************************ basic_robot.cpp ***************************
desarrollado usando Dev-C++ IDE V4.9.8.4 GNU / MinGW / GNU gcc
                    Sc1 IDE / BCC5.5
                    version orginal por Oscar Chang
*********************************************************************/

